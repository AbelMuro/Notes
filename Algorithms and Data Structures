LINEAR SEARCH: is a searching algorithm that goes through each element in the array, one by one. The time complexity 
              for this algorithm is O(n)

BINARY SEARCH: is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. 
               The idea of binary search is to use the information that the array is sorted and reduce the time 
               complexity to O(Log n). 
               
               EX:
               
                var search = function(nums, target) {
                    let middle;
                    let end =  nums.length - 1;
                    let start = 0;

                    while(start <= end){
                        middle = Math.floor((start + end) / 2);         //make sure to round down the result here 
                        if(nums[middle] > target)                       //we 
                            end = middle - 1;
                        else if(nums[middle] < target)
                            start = middle + 1;
                        else
                            return middle;
                    }
                    return -1;
                };


TWO POINTER MANIPULATION: Two pointers is an easy and effective technique that is typically used for searching pairs in a sorted array.
Given a sorted array A (sorted in ascending order), having N integers, find if there exists any pair of elements (A[i], A[j]) such that their sum is equal to X.
The time complexity for this algorithm is O(n)
            EX:
              
              let A = [1,2,3,4,5,6,7,8,9,10];
              let X = 10;
              
              for(let i = 0, j = A.length - 1; i < j; ){
                  if(A[i] + A[j] > X)
                      j++
                  
                  else if(A[i] + A[j] < X)
                      i++;
                    
                  else if(A[i] + A[j] == X)
                      return 1;
              
              }
    
    
    
SLIDING WINDOW ALGORITHM: This algorithm is designed save some re-calculation, the time complexity for this algorithm is O(n)


         EX:  Given an array of integers of size ‘n’, Our aim is to calculate the maximum sum of ‘k’ consecutive elements in the array.
                             
              arr = [100, 200, 300, 400]          k = 2
              output = 700
        
              function maxSum(arr, k) {
                  let max = 0;
                  let sum = 0;
                  
                  for (let i = 0; i < k; i++) {                  // find initial sum of first k elements
                      sum += arr[i];
                      max = sum;                                 // initially, sum = 300
                  }
                                                            // remember that i = k, so 'i' will point to the third element in the first iteration
                  for (let i = k; i < arr.length; i++) {    // first iteration: 
                      sum += arr[i] - arr[i - k];                 // sum = 300, so what we do here is add 300 and subtract 100 from sum
                      if (sum > max) {                            // so now the sum = 500, this is the sum of the second and third elements of the array 
                          max = sum;                              // this if statement is for unsorted arrays 
                      }
                  }
                  return max;
              }





